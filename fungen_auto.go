// Package sudoku - generated by fungen; DO NOT EDIT
package sudoku

import "sync"

// PosList is the type for a list that holds members of type Pos
type PosList []Pos

// MapInt is a method on PosList that takes a function of type Pos -> int and applies it to every member of PosList
func (l PosList) MapInt(f func(Pos) int) intList {
	l2 := make(intList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// Map is a method on PosList that takes a function of type Pos -> Pos and applies it to every member of PosList
func (l PosList) Map(f func(Pos) Pos) PosList {
	l2 := make(PosList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapCell is a method on PosList that takes a function of type Pos -> Cell and applies it to every member of PosList
func (l PosList) MapCell(f func(Pos) Cell) CellList {
	l2 := make(CellList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapNumCount is a method on PosList that takes a function of type Pos -> numCount and applies it to every member of PosList
func (l PosList) MapNumCount(f func(Pos) numCount) numCountList {
	l2 := make(numCountList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapInt8 is a method on PosList that takes a function of type Pos -> int8 and applies it to every member of PosList
func (l PosList) MapInt8(f func(Pos) int8) int8List {
	l2 := make(int8List, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// PMapCell is similar to MapCell except that it executes the function on each member in parallel.
func (l PosList) PMapCell(f func(Pos) Cell) CellList {
	wg := sync.WaitGroup{}
	l2 := make(CellList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Pos) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapNumCount is similar to MapNumCount except that it executes the function on each member in parallel.
func (l PosList) PMapNumCount(f func(Pos) numCount) numCountList {
	wg := sync.WaitGroup{}
	l2 := make(numCountList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Pos) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapInt8 is similar to MapInt8 except that it executes the function on each member in parallel.
func (l PosList) PMapInt8(f func(Pos) int8) int8List {
	wg := sync.WaitGroup{}
	l2 := make(int8List, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Pos) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapInt is similar to MapInt except that it executes the function on each member in parallel.
func (l PosList) PMapInt(f func(Pos) int) intList {
	wg := sync.WaitGroup{}
	l2 := make(intList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Pos) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMap is similar to Map except that it executes the function on each member in parallel.
func (l PosList) PMap(f func(Pos) Pos) PosList {
	wg := sync.WaitGroup{}
	l2 := make(PosList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Pos) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// Filter is a method on PosList that takes a function of type Pos -> bool returns a list of type PosList which contains all members from the original list for which the function returned true
func (l PosList) Filter(f func(Pos) bool) PosList {
	l2 := []Pos{}
	for _, t := range l {
		if f(t) {
			l2 = append(l2, t)
		}
	}
	return l2
}

// PFilter is similar to the Filter method except that the filter is applied to all the elements in parallel. The order of resulting elements cannot be guaranteed.
func (l PosList) PFilter(f func(Pos) bool) PosList {
	wg := sync.WaitGroup{}
	mutex := sync.Mutex{}
	l2 := []Pos{}
	for _, t := range l {
		wg.Add(1)
		go func(t Pos) {
			if f(t) {
				mutex.Lock()
				l2 = append(l2, t)
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// Reduce is a method on PosList that takes a function of type (Pos, Pos) -> Pos and returns a Pos which is the result of applying the function to all members of the original list starting from the first member
func (l PosList) Reduce(t1 Pos, f func(Pos, Pos) Pos) Pos {
	for _, t := range l {
		t1 = f(t1, t)
	}
	return t1
}

// ReduceRight is a method on PosList that takes a function of type (Pos, Pos) -> Pos and returns a Pos which is the result of applying the function to all members of the original list starting from the last member
func (l PosList) ReduceRight(t1 Pos, f func(Pos, Pos) Pos) Pos {
	for i := len(l) - 1; i >= 0; i-- {
		t := l[i]
		t1 = f(t, t1)
	}
	return t1
}

// Take is a method on PosList that takes an integer n and returns the first n elements of the original list. If the list contains fewer than n elements then the entire list is returned.
func (l PosList) Take(n int) PosList {
	if len(l) >= n {
		return l[:n]
	}
	return l
}

// TakeWhile is a method on PosList that takes a function of type Pos -> bool and returns a list of type PosList which includes only the first members from the original list for which the function returned true
func (l PosList) TakeWhile(f func(Pos) bool) PosList {
	for i, t := range l {
		if !f(t) {
			return l[:i]
		}
	}
	return l
}

// Drop is a method on PosList that takes an integer n and returns all but the first n elements of the original list. If the list contains fewer than n elements then an empty list is returned.
func (l PosList) Drop(n int) PosList {
	if len(l) >= n {
		return l[n:]
	}
	var l2 PosList
	return l2
}

// DropWhile is a method on PosList that takes a function of type Pos -> bool and returns a list of type PosList which excludes the first members from the original list for which the function returned true
func (l PosList) DropWhile(f func(Pos) bool) PosList {
	for i, t := range l {
		if !f(t) {
			return l[i:]
		}
	}
	var l2 PosList
	return l2
}

// Each is a method on PosList that takes a function of type Pos -> void and applies the function to each member of the list and then returns the original list.
func (l PosList) Each(f func(Pos)) PosList {
	for _, t := range l {
		f(t)
	}
	return l
}

// EachI is a method on PosList that takes a function of type (int, Pos) -> void and applies the function to each member of the list and then returns the original list. The int parameter to the function is the index of the element.
func (l PosList) EachI(f func(int, Pos)) PosList {
	for i, t := range l {
		f(i, t)
	}
	return l
}

// All is a method on PosList that returns true if all the members of the list satisfy a function or if the list is empty.
func (l PosList) All(f func(Pos) bool) bool {
	for _, t := range l {
		if !f(t) {
			return false
		}
	}
	return true
}

// Any is a method on PosList that returns true if at least one member of the list satisfies a function. It returns false if the list is empty.
func (l PosList) Any(f func(Pos) bool) bool {
	for _, t := range l {
		if f(t) {
			return true
		}
	}
	return false
}

// FilterMapCell is a method on PosList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l PosList) FilterMapCell(fMap func(Pos) Cell, fFilters ...func(Pos) bool) CellList {
	l2 := CellList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapNumCount is a method on PosList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l PosList) FilterMapNumCount(fMap func(Pos) numCount, fFilters ...func(Pos) bool) numCountList {
	l2 := numCountList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapInt8 is a method on PosList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l PosList) FilterMapInt8(fMap func(Pos) int8, fFilters ...func(Pos) bool) int8List {
	l2 := int8List{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapInt is a method on PosList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l PosList) FilterMapInt(fMap func(Pos) int, fFilters ...func(Pos) bool) intList {
	l2 := intList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// PFilterMapCell is similar to FilterMapCell except that it executes the method on each member in parallel.
func (l PosList) PFilterMapCell(fMap func(Pos) Cell, fFilters ...func(Pos) bool) CellList {
	l2 := CellList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Pos) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapNumCount is similar to FilterMapNumCount except that it executes the method on each member in parallel.
func (l PosList) PFilterMapNumCount(fMap func(Pos) numCount, fFilters ...func(Pos) bool) numCountList {
	l2 := numCountList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Pos) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapInt8 is similar to FilterMapInt8 except that it executes the method on each member in parallel.
func (l PosList) PFilterMapInt8(fMap func(Pos) int8, fFilters ...func(Pos) bool) int8List {
	l2 := int8List{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Pos) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapInt is similar to FilterMapInt except that it executes the method on each member in parallel.
func (l PosList) PFilterMapInt(fMap func(Pos) int, fFilters ...func(Pos) bool) intList {
	l2 := intList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Pos) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// CellList is the type for a list that holds members of type Cell
type CellList []Cell

// MapPos is a method on CellList that takes a function of type Cell -> Pos and applies it to every member of CellList
func (l CellList) MapPos(f func(Cell) Pos) PosList {
	l2 := make(PosList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// Map is a method on CellList that takes a function of type Cell -> Cell and applies it to every member of CellList
func (l CellList) Map(f func(Cell) Cell) CellList {
	l2 := make(CellList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapNumCount is a method on CellList that takes a function of type Cell -> numCount and applies it to every member of CellList
func (l CellList) MapNumCount(f func(Cell) numCount) numCountList {
	l2 := make(numCountList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapInt8 is a method on CellList that takes a function of type Cell -> int8 and applies it to every member of CellList
func (l CellList) MapInt8(f func(Cell) int8) int8List {
	l2 := make(int8List, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapInt is a method on CellList that takes a function of type Cell -> int and applies it to every member of CellList
func (l CellList) MapInt(f func(Cell) int) intList {
	l2 := make(intList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// PMapInt8 is similar to MapInt8 except that it executes the function on each member in parallel.
func (l CellList) PMapInt8(f func(Cell) int8) int8List {
	wg := sync.WaitGroup{}
	l2 := make(int8List, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Cell) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapInt is similar to MapInt except that it executes the function on each member in parallel.
func (l CellList) PMapInt(f func(Cell) int) intList {
	wg := sync.WaitGroup{}
	l2 := make(intList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Cell) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapPos is similar to MapPos except that it executes the function on each member in parallel.
func (l CellList) PMapPos(f func(Cell) Pos) PosList {
	wg := sync.WaitGroup{}
	l2 := make(PosList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Cell) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMap is similar to Map except that it executes the function on each member in parallel.
func (l CellList) PMap(f func(Cell) Cell) CellList {
	wg := sync.WaitGroup{}
	l2 := make(CellList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Cell) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapNumCount is similar to MapNumCount except that it executes the function on each member in parallel.
func (l CellList) PMapNumCount(f func(Cell) numCount) numCountList {
	wg := sync.WaitGroup{}
	l2 := make(numCountList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t Cell) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// Filter is a method on CellList that takes a function of type Cell -> bool returns a list of type CellList which contains all members from the original list for which the function returned true
func (l CellList) Filter(f func(Cell) bool) CellList {
	l2 := []Cell{}
	for _, t := range l {
		if f(t) {
			l2 = append(l2, t)
		}
	}
	return l2
}

// PFilter is similar to the Filter method except that the filter is applied to all the elements in parallel. The order of resulting elements cannot be guaranteed.
func (l CellList) PFilter(f func(Cell) bool) CellList {
	wg := sync.WaitGroup{}
	mutex := sync.Mutex{}
	l2 := []Cell{}
	for _, t := range l {
		wg.Add(1)
		go func(t Cell) {
			if f(t) {
				mutex.Lock()
				l2 = append(l2, t)
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// Reduce is a method on CellList that takes a function of type (Cell, Cell) -> Cell and returns a Cell which is the result of applying the function to all members of the original list starting from the first member
func (l CellList) Reduce(t1 Cell, f func(Cell, Cell) Cell) Cell {
	for _, t := range l {
		t1 = f(t1, t)
	}
	return t1
}

// ReduceRight is a method on CellList that takes a function of type (Cell, Cell) -> Cell and returns a Cell which is the result of applying the function to all members of the original list starting from the last member
func (l CellList) ReduceRight(t1 Cell, f func(Cell, Cell) Cell) Cell {
	for i := len(l) - 1; i >= 0; i-- {
		t := l[i]
		t1 = f(t, t1)
	}
	return t1
}

// Take is a method on CellList that takes an integer n and returns the first n elements of the original list. If the list contains fewer than n elements then the entire list is returned.
func (l CellList) Take(n int) CellList {
	if len(l) >= n {
		return l[:n]
	}
	return l
}

// TakeWhile is a method on CellList that takes a function of type Cell -> bool and returns a list of type CellList which includes only the first members from the original list for which the function returned true
func (l CellList) TakeWhile(f func(Cell) bool) CellList {
	for i, t := range l {
		if !f(t) {
			return l[:i]
		}
	}
	return l
}

// Drop is a method on CellList that takes an integer n and returns all but the first n elements of the original list. If the list contains fewer than n elements then an empty list is returned.
func (l CellList) Drop(n int) CellList {
	if len(l) >= n {
		return l[n:]
	}
	var l2 CellList
	return l2
}

// DropWhile is a method on CellList that takes a function of type Cell -> bool and returns a list of type CellList which excludes the first members from the original list for which the function returned true
func (l CellList) DropWhile(f func(Cell) bool) CellList {
	for i, t := range l {
		if !f(t) {
			return l[i:]
		}
	}
	var l2 CellList
	return l2
}

// Each is a method on CellList that takes a function of type Cell -> void and applies the function to each member of the list and then returns the original list.
func (l CellList) Each(f func(Cell)) CellList {
	for _, t := range l {
		f(t)
	}
	return l
}

// EachI is a method on CellList that takes a function of type (int, Cell) -> void and applies the function to each member of the list and then returns the original list. The int parameter to the function is the index of the element.
func (l CellList) EachI(f func(int, Cell)) CellList {
	for i, t := range l {
		f(i, t)
	}
	return l
}

// All is a method on CellList that returns true if all the members of the list satisfy a function or if the list is empty.
func (l CellList) All(f func(Cell) bool) bool {
	for _, t := range l {
		if !f(t) {
			return false
		}
	}
	return true
}

// Any is a method on CellList that returns true if at least one member of the list satisfies a function. It returns false if the list is empty.
func (l CellList) Any(f func(Cell) bool) bool {
	for _, t := range l {
		if f(t) {
			return true
		}
	}
	return false
}

// FilterMapPos is a method on CellList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l CellList) FilterMapPos(fMap func(Cell) Pos, fFilters ...func(Cell) bool) PosList {
	l2 := PosList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapNumCount is a method on CellList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l CellList) FilterMapNumCount(fMap func(Cell) numCount, fFilters ...func(Cell) bool) numCountList {
	l2 := numCountList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapInt8 is a method on CellList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l CellList) FilterMapInt8(fMap func(Cell) int8, fFilters ...func(Cell) bool) int8List {
	l2 := int8List{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapInt is a method on CellList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l CellList) FilterMapInt(fMap func(Cell) int, fFilters ...func(Cell) bool) intList {
	l2 := intList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// PFilterMapInt8 is similar to FilterMapInt8 except that it executes the method on each member in parallel.
func (l CellList) PFilterMapInt8(fMap func(Cell) int8, fFilters ...func(Cell) bool) int8List {
	l2 := int8List{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Cell) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapInt is similar to FilterMapInt except that it executes the method on each member in parallel.
func (l CellList) PFilterMapInt(fMap func(Cell) int, fFilters ...func(Cell) bool) intList {
	l2 := intList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Cell) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapPos is similar to FilterMapPos except that it executes the method on each member in parallel.
func (l CellList) PFilterMapPos(fMap func(Cell) Pos, fFilters ...func(Cell) bool) PosList {
	l2 := PosList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Cell) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapNumCount is similar to FilterMapNumCount except that it executes the method on each member in parallel.
func (l CellList) PFilterMapNumCount(fMap func(Cell) numCount, fFilters ...func(Cell) bool) numCountList {
	l2 := numCountList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t Cell) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// numCountList is the type for a list that holds members of type numCount
type numCountList []numCount

// MapPos is a method on numCountList that takes a function of type numCount -> Pos and applies it to every member of numCountList
func (l numCountList) MapPos(f func(numCount) Pos) PosList {
	l2 := make(PosList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapCell is a method on numCountList that takes a function of type numCount -> Cell and applies it to every member of numCountList
func (l numCountList) MapCell(f func(numCount) Cell) CellList {
	l2 := make(CellList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// Map is a method on numCountList that takes a function of type numCount -> numCount and applies it to every member of numCountList
func (l numCountList) Map(f func(numCount) numCount) numCountList {
	l2 := make(numCountList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapInt8 is a method on numCountList that takes a function of type numCount -> int8 and applies it to every member of numCountList
func (l numCountList) MapInt8(f func(numCount) int8) int8List {
	l2 := make(int8List, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapInt is a method on numCountList that takes a function of type numCount -> int and applies it to every member of numCountList
func (l numCountList) MapInt(f func(numCount) int) intList {
	l2 := make(intList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// PMapPos is similar to MapPos except that it executes the function on each member in parallel.
func (l numCountList) PMapPos(f func(numCount) Pos) PosList {
	wg := sync.WaitGroup{}
	l2 := make(PosList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t numCount) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapCell is similar to MapCell except that it executes the function on each member in parallel.
func (l numCountList) PMapCell(f func(numCount) Cell) CellList {
	wg := sync.WaitGroup{}
	l2 := make(CellList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t numCount) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMap is similar to Map except that it executes the function on each member in parallel.
func (l numCountList) PMap(f func(numCount) numCount) numCountList {
	wg := sync.WaitGroup{}
	l2 := make(numCountList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t numCount) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapInt8 is similar to MapInt8 except that it executes the function on each member in parallel.
func (l numCountList) PMapInt8(f func(numCount) int8) int8List {
	wg := sync.WaitGroup{}
	l2 := make(int8List, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t numCount) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapInt is similar to MapInt except that it executes the function on each member in parallel.
func (l numCountList) PMapInt(f func(numCount) int) intList {
	wg := sync.WaitGroup{}
	l2 := make(intList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t numCount) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// Filter is a method on numCountList that takes a function of type numCount -> bool returns a list of type numCountList which contains all members from the original list for which the function returned true
func (l numCountList) Filter(f func(numCount) bool) numCountList {
	l2 := []numCount{}
	for _, t := range l {
		if f(t) {
			l2 = append(l2, t)
		}
	}
	return l2
}

// PFilter is similar to the Filter method except that the filter is applied to all the elements in parallel. The order of resulting elements cannot be guaranteed.
func (l numCountList) PFilter(f func(numCount) bool) numCountList {
	wg := sync.WaitGroup{}
	mutex := sync.Mutex{}
	l2 := []numCount{}
	for _, t := range l {
		wg.Add(1)
		go func(t numCount) {
			if f(t) {
				mutex.Lock()
				l2 = append(l2, t)
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// Reduce is a method on numCountList that takes a function of type (numCount, numCount) -> numCount and returns a numCount which is the result of applying the function to all members of the original list starting from the first member
func (l numCountList) Reduce(t1 numCount, f func(numCount, numCount) numCount) numCount {
	for _, t := range l {
		t1 = f(t1, t)
	}
	return t1
}

// ReduceRight is a method on numCountList that takes a function of type (numCount, numCount) -> numCount and returns a numCount which is the result of applying the function to all members of the original list starting from the last member
func (l numCountList) ReduceRight(t1 numCount, f func(numCount, numCount) numCount) numCount {
	for i := len(l) - 1; i >= 0; i-- {
		t := l[i]
		t1 = f(t, t1)
	}
	return t1
}

// Take is a method on numCountList that takes an integer n and returns the first n elements of the original list. If the list contains fewer than n elements then the entire list is returned.
func (l numCountList) Take(n int) numCountList {
	if len(l) >= n {
		return l[:n]
	}
	return l
}

// TakeWhile is a method on numCountList that takes a function of type numCount -> bool and returns a list of type numCountList which includes only the first members from the original list for which the function returned true
func (l numCountList) TakeWhile(f func(numCount) bool) numCountList {
	for i, t := range l {
		if !f(t) {
			return l[:i]
		}
	}
	return l
}

// Drop is a method on numCountList that takes an integer n and returns all but the first n elements of the original list. If the list contains fewer than n elements then an empty list is returned.
func (l numCountList) Drop(n int) numCountList {
	if len(l) >= n {
		return l[n:]
	}
	var l2 numCountList
	return l2
}

// DropWhile is a method on numCountList that takes a function of type numCount -> bool and returns a list of type numCountList which excludes the first members from the original list for which the function returned true
func (l numCountList) DropWhile(f func(numCount) bool) numCountList {
	for i, t := range l {
		if !f(t) {
			return l[i:]
		}
	}
	var l2 numCountList
	return l2
}

// Each is a method on numCountList that takes a function of type numCount -> void and applies the function to each member of the list and then returns the original list.
func (l numCountList) Each(f func(numCount)) numCountList {
	for _, t := range l {
		f(t)
	}
	return l
}

// EachI is a method on numCountList that takes a function of type (int, numCount) -> void and applies the function to each member of the list and then returns the original list. The int parameter to the function is the index of the element.
func (l numCountList) EachI(f func(int, numCount)) numCountList {
	for i, t := range l {
		f(i, t)
	}
	return l
}

// All is a method on numCountList that returns true if all the members of the list satisfy a function or if the list is empty.
func (l numCountList) All(f func(numCount) bool) bool {
	for _, t := range l {
		if !f(t) {
			return false
		}
	}
	return true
}

// Any is a method on numCountList that returns true if at least one member of the list satisfies a function. It returns false if the list is empty.
func (l numCountList) Any(f func(numCount) bool) bool {
	for _, t := range l {
		if f(t) {
			return true
		}
	}
	return false
}

// FilterMapCell is a method on numCountList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l numCountList) FilterMapCell(fMap func(numCount) Cell, fFilters ...func(numCount) bool) CellList {
	l2 := CellList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapInt8 is a method on numCountList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l numCountList) FilterMapInt8(fMap func(numCount) int8, fFilters ...func(numCount) bool) int8List {
	l2 := int8List{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapInt is a method on numCountList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l numCountList) FilterMapInt(fMap func(numCount) int, fFilters ...func(numCount) bool) intList {
	l2 := intList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapPos is a method on numCountList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l numCountList) FilterMapPos(fMap func(numCount) Pos, fFilters ...func(numCount) bool) PosList {
	l2 := PosList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// PFilterMapInt8 is similar to FilterMapInt8 except that it executes the method on each member in parallel.
func (l numCountList) PFilterMapInt8(fMap func(numCount) int8, fFilters ...func(numCount) bool) int8List {
	l2 := int8List{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t numCount) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapInt is similar to FilterMapInt except that it executes the method on each member in parallel.
func (l numCountList) PFilterMapInt(fMap func(numCount) int, fFilters ...func(numCount) bool) intList {
	l2 := intList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t numCount) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapPos is similar to FilterMapPos except that it executes the method on each member in parallel.
func (l numCountList) PFilterMapPos(fMap func(numCount) Pos, fFilters ...func(numCount) bool) PosList {
	l2 := PosList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t numCount) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapCell is similar to FilterMapCell except that it executes the method on each member in parallel.
func (l numCountList) PFilterMapCell(fMap func(numCount) Cell, fFilters ...func(numCount) bool) CellList {
	l2 := CellList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t numCount) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// int8List is the type for a list that holds members of type int8
type int8List []int8

// MapNumCount is a method on int8List that takes a function of type int8 -> numCount and applies it to every member of int8List
func (l int8List) MapNumCount(f func(int8) numCount) numCountList {
	l2 := make(numCountList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// Map is a method on int8List that takes a function of type int8 -> int8 and applies it to every member of int8List
func (l int8List) Map(f func(int8) int8) int8List {
	l2 := make(int8List, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapInt is a method on int8List that takes a function of type int8 -> int and applies it to every member of int8List
func (l int8List) MapInt(f func(int8) int) intList {
	l2 := make(intList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapPos is a method on int8List that takes a function of type int8 -> Pos and applies it to every member of int8List
func (l int8List) MapPos(f func(int8) Pos) PosList {
	l2 := make(PosList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapCell is a method on int8List that takes a function of type int8 -> Cell and applies it to every member of int8List
func (l int8List) MapCell(f func(int8) Cell) CellList {
	l2 := make(CellList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// PMapCell is similar to MapCell except that it executes the function on each member in parallel.
func (l int8List) PMapCell(f func(int8) Cell) CellList {
	wg := sync.WaitGroup{}
	l2 := make(CellList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int8) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapNumCount is similar to MapNumCount except that it executes the function on each member in parallel.
func (l int8List) PMapNumCount(f func(int8) numCount) numCountList {
	wg := sync.WaitGroup{}
	l2 := make(numCountList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int8) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMap is similar to Map except that it executes the function on each member in parallel.
func (l int8List) PMap(f func(int8) int8) int8List {
	wg := sync.WaitGroup{}
	l2 := make(int8List, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int8) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapInt is similar to MapInt except that it executes the function on each member in parallel.
func (l int8List) PMapInt(f func(int8) int) intList {
	wg := sync.WaitGroup{}
	l2 := make(intList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int8) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapPos is similar to MapPos except that it executes the function on each member in parallel.
func (l int8List) PMapPos(f func(int8) Pos) PosList {
	wg := sync.WaitGroup{}
	l2 := make(PosList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int8) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// Filter is a method on int8List that takes a function of type int8 -> bool returns a list of type int8List which contains all members from the original list for which the function returned true
func (l int8List) Filter(f func(int8) bool) int8List {
	l2 := []int8{}
	for _, t := range l {
		if f(t) {
			l2 = append(l2, t)
		}
	}
	return l2
}

// PFilter is similar to the Filter method except that the filter is applied to all the elements in parallel. The order of resulting elements cannot be guaranteed.
func (l int8List) PFilter(f func(int8) bool) int8List {
	wg := sync.WaitGroup{}
	mutex := sync.Mutex{}
	l2 := []int8{}
	for _, t := range l {
		wg.Add(1)
		go func(t int8) {
			if f(t) {
				mutex.Lock()
				l2 = append(l2, t)
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// Reduce is a method on int8List that takes a function of type (int8, int8) -> int8 and returns a int8 which is the result of applying the function to all members of the original list starting from the first member
func (l int8List) Reduce(t1 int8, f func(int8, int8) int8) int8 {
	for _, t := range l {
		t1 = f(t1, t)
	}
	return t1
}

// ReduceRight is a method on int8List that takes a function of type (int8, int8) -> int8 and returns a int8 which is the result of applying the function to all members of the original list starting from the last member
func (l int8List) ReduceRight(t1 int8, f func(int8, int8) int8) int8 {
	for i := len(l) - 1; i >= 0; i-- {
		t := l[i]
		t1 = f(t, t1)
	}
	return t1
}

// Take is a method on int8List that takes an integer n and returns the first n elements of the original list. If the list contains fewer than n elements then the entire list is returned.
func (l int8List) Take(n int) int8List {
	if len(l) >= n {
		return l[:n]
	}
	return l
}

// TakeWhile is a method on int8List that takes a function of type int8 -> bool and returns a list of type int8List which includes only the first members from the original list for which the function returned true
func (l int8List) TakeWhile(f func(int8) bool) int8List {
	for i, t := range l {
		if !f(t) {
			return l[:i]
		}
	}
	return l
}

// Drop is a method on int8List that takes an integer n and returns all but the first n elements of the original list. If the list contains fewer than n elements then an empty list is returned.
func (l int8List) Drop(n int) int8List {
	if len(l) >= n {
		return l[n:]
	}
	var l2 int8List
	return l2
}

// DropWhile is a method on int8List that takes a function of type int8 -> bool and returns a list of type int8List which excludes the first members from the original list for which the function returned true
func (l int8List) DropWhile(f func(int8) bool) int8List {
	for i, t := range l {
		if !f(t) {
			return l[i:]
		}
	}
	var l2 int8List
	return l2
}

// Each is a method on int8List that takes a function of type int8 -> void and applies the function to each member of the list and then returns the original list.
func (l int8List) Each(f func(int8)) int8List {
	for _, t := range l {
		f(t)
	}
	return l
}

// EachI is a method on int8List that takes a function of type (int, int8) -> void and applies the function to each member of the list and then returns the original list. The int parameter to the function is the index of the element.
func (l int8List) EachI(f func(int, int8)) int8List {
	for i, t := range l {
		f(i, t)
	}
	return l
}

// All is a method on int8List that returns true if all the members of the list satisfy a function or if the list is empty.
func (l int8List) All(f func(int8) bool) bool {
	for _, t := range l {
		if !f(t) {
			return false
		}
	}
	return true
}

// Any is a method on int8List that returns true if at least one member of the list satisfies a function. It returns false if the list is empty.
func (l int8List) Any(f func(int8) bool) bool {
	for _, t := range l {
		if f(t) {
			return true
		}
	}
	return false
}

// FilterMapInt is a method on int8List that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l int8List) FilterMapInt(fMap func(int8) int, fFilters ...func(int8) bool) intList {
	l2 := intList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapPos is a method on int8List that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l int8List) FilterMapPos(fMap func(int8) Pos, fFilters ...func(int8) bool) PosList {
	l2 := PosList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapCell is a method on int8List that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l int8List) FilterMapCell(fMap func(int8) Cell, fFilters ...func(int8) bool) CellList {
	l2 := CellList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapNumCount is a method on int8List that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l int8List) FilterMapNumCount(fMap func(int8) numCount, fFilters ...func(int8) bool) numCountList {
	l2 := numCountList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// PFilterMapCell is similar to FilterMapCell except that it executes the method on each member in parallel.
func (l int8List) PFilterMapCell(fMap func(int8) Cell, fFilters ...func(int8) bool) CellList {
	l2 := CellList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int8) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapNumCount is similar to FilterMapNumCount except that it executes the method on each member in parallel.
func (l int8List) PFilterMapNumCount(fMap func(int8) numCount, fFilters ...func(int8) bool) numCountList {
	l2 := numCountList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int8) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapInt is similar to FilterMapInt except that it executes the method on each member in parallel.
func (l int8List) PFilterMapInt(fMap func(int8) int, fFilters ...func(int8) bool) intList {
	l2 := intList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int8) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapPos is similar to FilterMapPos except that it executes the method on each member in parallel.
func (l int8List) PFilterMapPos(fMap func(int8) Pos, fFilters ...func(int8) bool) PosList {
	l2 := PosList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int8) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// intList is the type for a list that holds members of type int
type intList []int

// MapPos is a method on intList that takes a function of type int -> Pos and applies it to every member of intList
func (l intList) MapPos(f func(int) Pos) PosList {
	l2 := make(PosList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapCell is a method on intList that takes a function of type int -> Cell and applies it to every member of intList
func (l intList) MapCell(f func(int) Cell) CellList {
	l2 := make(CellList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapNumCount is a method on intList that takes a function of type int -> numCount and applies it to every member of intList
func (l intList) MapNumCount(f func(int) numCount) numCountList {
	l2 := make(numCountList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// MapInt8 is a method on intList that takes a function of type int -> int8 and applies it to every member of intList
func (l intList) MapInt8(f func(int) int8) int8List {
	l2 := make(int8List, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// Map is a method on intList that takes a function of type int -> int and applies it to every member of intList
func (l intList) Map(f func(int) int) intList {
	l2 := make(intList, len(l))
	for i, t := range l {
		l2[i] = f(t)
	}
	return l2
}

// PMap is similar to Map except that it executes the function on each member in parallel.
func (l intList) PMap(f func(int) int) intList {
	wg := sync.WaitGroup{}
	l2 := make(intList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapPos is similar to MapPos except that it executes the function on each member in parallel.
func (l intList) PMapPos(f func(int) Pos) PosList {
	wg := sync.WaitGroup{}
	l2 := make(PosList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapCell is similar to MapCell except that it executes the function on each member in parallel.
func (l intList) PMapCell(f func(int) Cell) CellList {
	wg := sync.WaitGroup{}
	l2 := make(CellList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapNumCount is similar to MapNumCount except that it executes the function on each member in parallel.
func (l intList) PMapNumCount(f func(int) numCount) numCountList {
	wg := sync.WaitGroup{}
	l2 := make(numCountList, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// PMapInt8 is similar to MapInt8 except that it executes the function on each member in parallel.
func (l intList) PMapInt8(f func(int) int8) int8List {
	wg := sync.WaitGroup{}
	l2 := make(int8List, len(l))
	for i, t := range l {
		wg.Add(1)
		go func(i int, t int) {
			l2[i] = f(t)
			wg.Done()
		}(i, t)
	}
	wg.Wait()
	return l2
}

// Filter is a method on intList that takes a function of type int -> bool returns a list of type intList which contains all members from the original list for which the function returned true
func (l intList) Filter(f func(int) bool) intList {
	l2 := []int{}
	for _, t := range l {
		if f(t) {
			l2 = append(l2, t)
		}
	}
	return l2
}

// PFilter is similar to the Filter method except that the filter is applied to all the elements in parallel. The order of resulting elements cannot be guaranteed.
func (l intList) PFilter(f func(int) bool) intList {
	wg := sync.WaitGroup{}
	mutex := sync.Mutex{}
	l2 := []int{}
	for _, t := range l {
		wg.Add(1)
		go func(t int) {
			if f(t) {
				mutex.Lock()
				l2 = append(l2, t)
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// Reduce is a method on intList that takes a function of type (int, int) -> int and returns a int which is the result of applying the function to all members of the original list starting from the first member
func (l intList) Reduce(t1 int, f func(int, int) int) int {
	for _, t := range l {
		t1 = f(t1, t)
	}
	return t1
}

// ReduceRight is a method on intList that takes a function of type (int, int) -> int and returns a int which is the result of applying the function to all members of the original list starting from the last member
func (l intList) ReduceRight(t1 int, f func(int, int) int) int {
	for i := len(l) - 1; i >= 0; i-- {
		t := l[i]
		t1 = f(t, t1)
	}
	return t1
}

// Take is a method on intList that takes an integer n and returns the first n elements of the original list. If the list contains fewer than n elements then the entire list is returned.
func (l intList) Take(n int) intList {
	if len(l) >= n {
		return l[:n]
	}
	return l
}

// TakeWhile is a method on intList that takes a function of type int -> bool and returns a list of type intList which includes only the first members from the original list for which the function returned true
func (l intList) TakeWhile(f func(int) bool) intList {
	for i, t := range l {
		if !f(t) {
			return l[:i]
		}
	}
	return l
}

// Drop is a method on intList that takes an integer n and returns all but the first n elements of the original list. If the list contains fewer than n elements then an empty list is returned.
func (l intList) Drop(n int) intList {
	if len(l) >= n {
		return l[n:]
	}
	var l2 intList
	return l2
}

// DropWhile is a method on intList that takes a function of type int -> bool and returns a list of type intList which excludes the first members from the original list for which the function returned true
func (l intList) DropWhile(f func(int) bool) intList {
	for i, t := range l {
		if !f(t) {
			return l[i:]
		}
	}
	var l2 intList
	return l2
}

// Each is a method on intList that takes a function of type int -> void and applies the function to each member of the list and then returns the original list.
func (l intList) Each(f func(int)) intList {
	for _, t := range l {
		f(t)
	}
	return l
}

// EachI is a method on intList that takes a function of type (int, int) -> void and applies the function to each member of the list and then returns the original list. The int parameter to the function is the index of the element.
func (l intList) EachI(f func(int, int)) intList {
	for i, t := range l {
		f(i, t)
	}
	return l
}

// All is a method on intList that returns true if all the members of the list satisfy a function or if the list is empty.
func (l intList) All(f func(int) bool) bool {
	for _, t := range l {
		if !f(t) {
			return false
		}
	}
	return true
}

// Any is a method on intList that returns true if at least one member of the list satisfies a function. It returns false if the list is empty.
func (l intList) Any(f func(int) bool) bool {
	for _, t := range l {
		if f(t) {
			return true
		}
	}
	return false
}

// FilterMapPos is a method on intList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l intList) FilterMapPos(fMap func(int) Pos, fFilters ...func(int) bool) PosList {
	l2 := PosList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapCell is a method on intList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l intList) FilterMapCell(fMap func(int) Cell, fFilters ...func(int) bool) CellList {
	l2 := CellList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapNumCount is a method on intList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l intList) FilterMapNumCount(fMap func(int) numCount, fFilters ...func(int) bool) numCountList {
	l2 := numCountList{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// FilterMapInt8 is a method on intList that applies the filter(s) and map to the list members in a single loop and returns the resulting list.
func (l intList) FilterMapInt8(fMap func(int) int8, fFilters ...func(int) bool) int8List {
	l2 := int8List{}
	for _, t := range l {
		pass := true
		for _, f := range fFilters {
			if !f(t) {
				pass = false
				break
			}
		}
		if pass {
			l2 = append(l2, fMap(t))
		}
	}
	return l2
}

// PFilterMapPos is similar to FilterMapPos except that it executes the method on each member in parallel.
func (l intList) PFilterMapPos(fMap func(int) Pos, fFilters ...func(int) bool) PosList {
	l2 := PosList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapCell is similar to FilterMapCell except that it executes the method on each member in parallel.
func (l intList) PFilterMapCell(fMap func(int) Cell, fFilters ...func(int) bool) CellList {
	l2 := CellList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapNumCount is similar to FilterMapNumCount except that it executes the method on each member in parallel.
func (l intList) PFilterMapNumCount(fMap func(int) numCount, fFilters ...func(int) bool) numCountList {
	l2 := numCountList{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}

// PFilterMapInt8 is similar to FilterMapInt8 except that it executes the method on each member in parallel.
func (l intList) PFilterMapInt8(fMap func(int) int8, fFilters ...func(int) bool) int8List {
	l2 := int8List{}
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(l))

	for _, t := range l {
		go func(t int) {
			pass := true
			for _, f := range fFilters {
				if !f(t) {
					pass = false
					break
				}
			}
			if pass {
				mutex.Lock()
				l2 = append(l2, fMap(t))
				mutex.Unlock()
			}
			wg.Done()
		}(t)
	}
	wg.Wait()
	return l2
}
